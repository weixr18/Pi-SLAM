    /*
    if(tmp_count % 5 == 0){            
        // show bin map
        cv::Mat* binMap = GetOccupyMapImage();
        Eigen::Vector2d arrowHead = mCamDirection + mCamPos;
        Eigen::Vector2d arrowHead2dPos = Get2dPos(arrowHead(0), arrowHead(1));
        unsigned int xArrowHead = arrowHead2dPos(0);
        unsigned int zArrowHead = arrowHead2dPos(1);
        
        cv::arrowedLine(*binMap, cv::Point(xCam, mzScale-zCam), \
            cv::Point(xArrowHead, mzScale-zArrowHead), 255, 1, 8, 0, 0.1);
        ShowImage(*binMap, "Occupation map");
    }
    tmp_count += 1;
    */

    /*** error map ***/
typedef std:unordered_map<g2o::OptimizableGraph::Edge*, Eigen::Vector2d> PosMap;
typedef std:pair<g2o::OptimizableGraph::Edge*, Eigen::Vector2d> PosMapItem;

void Map2d::UpdateError(EdgeContainer& activeEdges){
    // TODO
    int xScale = m2dScale.xScale;
    int zScale = m2dScale.zScale;
    
    // get updating (x,z) range
    int xmin = 9999;
    int xmax = -9999;
    int zmin = 9999;
    int zmax = -9999;
    PosMap posMap();
    for (int k = 0; k < static_cast<int>(activeEdges.size()); ++k) {
        g2o::OptimizableGraph::Edge* e = activeEdges[k];
        if(e == nullptr){
            continue;
        }
        ConstVtxMapPoint vMapPoint = static_cast<ConstVtxMapPoint>(e->vertices()[0]);
        Eigen::Vector3d pos3d = vMapPoint->estimate();
        Eigen::Vector2d pos2d = Get2dPos(pos3d);
        int x = (int)pos2d(0);
        int z = (int)pos2d(1);
        if(x < 0 || x > xScale){
            continue;
        }
        if(z < 0 || z > zScale){
            continue;
        }
        if(x > xmax) xmax = x; 
        if(x < xmin) xmin = x;
        if(z > zmax) zmax = z; 
        if(z < zmin) zmin = z; 

        PosMapItem item(e, pos2d);
        posMap.insert(item);
    }
    if(xmin > xmax || zmin > zmax){
        std::cout << "[UpdateError] " << "Error: no edge in optimize graph." << std::endl;
        return;
    }
    
    // fill temp error map
    int xRange = xmax + 1 - xmin;
    int zRange = zmax + 1 - zmin;
    cv::Mat* tmpErrorMap = new cv::Mat(cv::zeros(xRange, zRange, 6)); // CV_64FC1
    for (int k = 0; k < static_cast<int>(activeEdges.size()); ++k) {
        // get error
        g2o::OptimizableGraph::Edge* e = activeEdges[k];
        if(e == nullptr){
            continue;
        }
        double errorSqr;
        if (e->robustKernel()) {
            Eigen::Vector3d tmp;
            e->robustKernel()->robustify(e->chi2(), tmp);
            errorSqr = tmp[0];
        }
        else{
            errorSqr = e->chi2();
        }
        
        if(posMap.find(e) == posMap.end()){
            continue;
        }
        Eigen::Vector2d pos2d = posMap[e];
        int tmpX = pos2d(0) - xmin;
        int tmpZ = pos2d(1) - zmin;
        tmpErrorMap->at<double>(tmpX, tmpZ) += errorSqr;
    }
    
    // blur
    cv::Mat* blurredErrorMap = new cv::Mat(cv::Mat::zeros(zScale, xScale, 6)); // CV_64FC1
    GaussianBlur(*tmpErrorMap, *blurredErrorMap, cv::Size(11, 11), 0, 0);
    
    
    std::unique_lock<std::mutex> mapUpdateLock(mMutexMapUpdate); // add lock
    mMapData[x][z].baError += std::sqrt(errorSqr);

    cv::Mat* errMap = GetErrorMapImage();
    cv::Mat* colorErrMap = GetErrorMapImageColor(errMap);
    ShowImage(*colorErrMap, "Color Error Map");
    delete errMap;
    delete colorErrMap;
}